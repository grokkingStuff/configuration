#+TITLE: Configs & Dotfiles
#+AUTHOR: Vishakh Kumar
#+EMAIL: vishakhpradeepkumar@gmail.com
#+LICENSE: GPLv3
#+LANGUAGE: en
#+OPTIONS: num:5 whn:2 toc:4 H:6

#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS


 #+NAME: connect.sh
 #+CAPTION: The overall structure of connect.sh
 #+BEGIN_SRC sh :tangle install.sh :noweb yes
   #!/usr/bin/env bash
   ## Description: Connects to remote server and relays local changes made in git repo and opens a shell in remote server.


                     <<author_information>>


   <<license_information>>

   
   <<system_library>>
   

   # MAIN CONTROL FLOW
   function main() {

   colour_init
   fg_green
   #<<preamble_library>>

   #bot "Installing applications"
   #<<applications_to_install>>
   #ok "Installed applications!"

   }

   main "$@"
 #+END_SRC

** DONE Author Information
   CLOSED: [2018-06-15 Fri 21:59]
Because someone needs to take the blame for when this script goes insane. Seriously, someone take this piece of shit code from me and make it better. Free brownies for whoever does that.

 #+NAME: author_information
 #+BEGIN_SRC sh :noweb yes
################################################
#                                              #
#              Author Information              #
#                                              #
# Author: Vishakh Pradeep Kumar                #
# Email: grokkingStuff@gmail.com on 04-2018    #
# Current maintainer: Vishakh Pradeep Kumar    #
################################################
 #+END_SRC

** DONE License information
   CLOSED: [2018-06-15 Fri 21:59]
Even if it seems pretentious, it's good to have a license so that other people can use it. Since this code isn't exactly going to be used in a production environment, I'm going to stick a Gsyntax-checkingPL license on it.

#+NAME: license_information
#+BEGIN_SRC sh :noweb yes
#####################################################################################
#                                                                                   #
#                                License Information                                #
#                                                                                   #
# License: GPLv2, see http://www.fsf.org/licensing/licenses/info/GPLv2.html         #
# and accompanying license "LICENSE.txt". Redistribution + modification under this  #
# license permitted.                                                                #
# If you enclose this script or parts of it in your software, it has to             #
# be accompanied by the same license (see link) and the place where to get          #
# the recent version of this program: https://testssl.sh                            #
# Don't violate the license.                                                        #
#                                                                                   #
# USAGE WITHOUT ANY WARRANTY, THE SOFTWARE IS PROVIDED "AS IS". USE IT AT           #
# your OWN RISK                                                                     #
#####################################################################################
#+END_SRC

* Bash Library
Bash is a pain in the ass to work with if you need to be safe. This library allows you to write bash that's well-organized, somewhat tested, and hopefully cross platform.

** Preamble
  For all the stuff that doesn't really matter to the structure of the program but is quite important for everything else.
  Most of this should be taken care of by the configBot.
 #+NAME: preamble_library
 #+CAPTION: Preamble src block
  #+BEGIN_SRC sh :noweb yes
  #+END_SRC
*** Example of an implementation of getopts and constants that's not bad
 #+CAPTION: Implementation of getopts
 #+BEGIN_SRC sh :noweb yes
 #########################
 # Constants Declaration #
 #########################

 # Home computer information
 USER_VCS_REPO="$(system::vcs_repo_root)"
 USER_MACHINE="$(system::detect_operating_system)"

 # Remote user information
 REMOTE_IPADDRESS='143.215.98.17'
 REMOTE_USER='pi'
 REMOTE_USER_PASSWORD='raspberry'
 REMOTE_LOCATION='/home/pi/Github/2018'

 #######################
 # User input & Flags  #
 #######################

 while getopts ":iufph:*" o; do
     case "${o}" in

         i) ## IP Address flag. Specify ip address. Default is 143.215.98.17
             REMOTE_IPADDRESS="${OPTARG}" 
             ;;

         u) ## Remote username flag. Specify username of raspberry pi. Default is 'pi'
             REMOTE_USER="${OPTARG}" 
             ;;

         f) ## Location of remote folder flag. Specify location of github repo on raspberry pi. Change only if not working on 2018 folder 
             REMOTE_LOCATION="${OPTARG}"
             ;;

         p) ## Password flag. Specify a password for user on remote server
             REMOTE_USER_PASSWORD="${OPTARG}"
             ;;

         h) ## Help flag. Displays flag options 
             system::usage
             exit 0
             ;;

         :)  # For when a mandatory argument is skipped.
             system::err "Option -$OPTARG requires an argument."
             system::usage
             exit 1
             ;;
         *) 
             system::err "Unexpected option ${flag}"
             system::usage
             exit 1 
             ;;
     esac
 done

 ##############################
 # Constants turned read-only #
 ##############################

 # Home computer information
 readonly USER_VCS_REPO
 readonly USER_MACHINE

 # Remote user information
 readonly REMOTE_IPADDRESS
 readonly REMOTE_USER
 readonly REMOTE_USER_PASSWORD
 readonly REMOTE_LOCATION
 #+END_SRC

** System library                                              :library:bash:

 Functions that are used to query or support the system fall under this library.

 #+NAME: system_library
 #+BEGIN_SRC sh :noweb yes 
 
 # SYSTEEM LIBRARY
 
 <<system::help_dialog>>
 <<system::detect_operating_system>>
 <<system::err>>
 <<system::check_required_programs>>
 <<system::vcs_repo_root>>
 <<system::color_initialization>>
 <<system::echo>>
 #+END_SRC

*** Help prompt
  A quick and effective help function that uses the comments in the flag case block. Scans this file for a "##" in front of a ")" and displays those lines exclusively.
  Restrict comments to single # to avoid unnecessary mixup.

  #+NAME: system::help_dialog
  #+BEGIN_SRC sh
 ########################################################
 # Displays a list of all flags with their descriptions
 # Globals:
 #   None
 # Arguments:
 #   None
 # Returns:
 #   None
 ########################################################
 function system::usage() {
     echo "$0 usage:" &&              \
       grep "[[:space:]].)\\ ##" "$0" |  \         # Find all line in script that have '##' after a ')'
       sed 's/##//' |                 \         # Replace all '##' with nothing
       sed -r 's/([a-z])\)/-\1/';              # TODO Can't remember
 }
  #+END_SRC
*** Detect operating system                                   :function:bash:
 Since this command will be executed by different people of multiple operating systems, I've decided to use as many bash built-ins as possible for portability. However, there are still things that need to be set for each operating system. This code block detects the operating system and makes it available in the variable $MACHINE. I was gonna hack together a way to do this using the uname command but I think using  pre-defined $OSTYPE variable is cleaner.


 - I can't run this in CMD.EXE! What do I do?

   CMD.EXE does not have an inbuilt utility to run sh files. You can install a Linux shell for Windows which should be more than adequate for your purposes. Alternatively, you can install Powershell & Cygwin, although the Linux shell is definitely recommended. Just to be clear, CMD.EXE can run scripts! It's just that no sane man would bother building a good script in a .cmd file.

 - This doesn't run on my OS.

   Huh. That's pretty interesting. This script should run on any system that supports bash (although it may have a few eccentricities.)
   If you're sure it's not your fault, you should totally send me an email about that.

 - This particular function seems too useful for a simple script like this. It's not bad.

   I'm glad you think so! It's really there because I fell down a rabbit hole and I overestimated the importance of being ultra-portable. 
   Use it if you can in your own scripts!

 #+NAME: system::detect_operating_system
 #+CAPTION: bash function to detect the operating system the shell is running on.
 #+BEGIN_SRC sh
 #################################################################
 # Detects the operating system that this script is being run on
 # Globals:
 #   OSTYPE
 # Arguments:
 #   None
 # Returns:
 #   MACHINE
 #################################################################
 function system::detect_operating_system() {

     local MACHINE
     MACHINE=""
    
     case "$OSTYPE" in

     #########################################################################
     # *nix systems                                                          #
     #########################################################################
         solaris*)
             MACHINE="SOLARIS"                                                     # Do people even use Solaris anymore? Gosh, haven't heard this name in a while.
             ;;
         darwin*)
             MACHINE="OSX"
             ;;
         linux*)
             MACHINE="LINUX"
             ;;
         bsd*)
             MACHINE="BSD"
             ;;
     #    aix*)
     #        MACHINE="AIX"
     #        ;;
     #    #Was gonna add AIX but I dunno if it has the $OSTYPE variable and I don't really care.
    

     #########################################################################
     # windows systems                                                       #
     #########################################################################
         cygwin*)
             MACHINE="WINDOWS"
             ;&                                                                    # Since Windows has two options for $OSTYPE, we're gonna let it cascade into the next case
         msys*)
             MACHINE="WINDOWS"

                                                                                   # We're using uname -s to figure out which shell in Windows we're using.
             unameOut="$(uname -s)"
             case "${unameOut}" in
                 CYGWIN*)
                     MACHINE="WINDOWS-CYGWIN"
                     # This should work for git shell as well.
                     # I'm not sure why you're using git-shell to do anything except run git commands but cool. You do you, mate.
                     ;;
                 MINGW32_NT*)
                     MACHINE="WINDOWS-32"
                     ;;
                 MINGW64_NT*)
                     MACHINE="WINDOWS-64"
                     ;;
                 Linux*)
                     MACHINE="WINDOWS-POWERSHELL"
                     # Not sure why Powershell returns Linux when uname-s is passed to it. Seems janky.
                     echo "This script will not run in Powershell. Please install a bash shell."
                     echo "Terminating program."
                     exit 1

             esac
             ;;
    
     #########################################################################
     # This shouldn't happen but I'm super interested if it does!            #
     #########################################################################
         *)
             MACHINE="unknown: $OSTYPE"
             echo "I don't know what you're running but I'm interested! Send me an email at grokkingStuff@gmail.com"
             echo "I'm guessing you're running some sort of custom unix machine so as long as you have access to bash, you should be good."
             echo "I mean, seriously, what are you running! Is it a really old system and if so, can you send me pics? pretty please!"
             echo "If you do have issues, do send me a email but I can't promise I can make it work on your system."
             ;;
     esac

     # Time to return the answer
     return "$MACHINE"
 }
 #+END_SRC

*** Sending time-tagged strings into STDERR                   :function:bash:

 All error messages should go to STDERR (standard error), including user defined errors. This function attaches a date and time to a string and passes it to STDERR
 Reference: [[https://google.github.io/styleguide/shell.xml?showone=STDOUT_vs_STDERR#STDOUT_vs_STDERR][Google Style Sheet: STDOUT vs STDERR]]

 #+NAME: system::err
 #+CAPTION: Function to generate errors and logs with attached date and time.
 #+BEGIN_SRC sh
 ###########################################################
 # Allows for user to send time-tagged strings into STDERR
 # Globals:
 #   None
 # Arguments:
 #   Array of String(s)
 # Returns:
 #   None
 ###########################################################
 function system::err() {
   echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@" >&2
 }
 #+END_SRC

*** Check if required programs are installed                  :function:bash:
 While this should ideally be taken care of by testing on different systems and by using portable bash builtins, there really isn't a substitute to checking if the command/program you're looking for is installed on the computer.

 #+NAME: system::check_required_programs
 #+BEGIN_SRC sh
 #####################################################################################
 # Checks if the list of commands given to it is executable and available on a system
 # Globals:
 #   None
 # Arguments:
 #
 # Returns:
 #   None
 #####################################################################################
 function system::check_required_programs() {
   for p in ${@}; do
     hash "${p}" 2>&- || \
         { system::err "Required program \"${p}\" not installed or in search PATH.";
           exit 1;
         }
   done
 }
 #+END_SRC

*** Detect VCS system and find root directory                 :function:bash:

 So it turns out that different VCS have different ways of querying for the location of the root folder. Since I've only used git and I've dabbled in Mercurial, this code might be outdated and downright wrong. However, gonna stick this in here since it might be handy.

 #+NAME: system::vcs_repo_root
 #+CAPTION: Function to return root of vcs repository when possible 
 #+BEGIN_SRC sh
 ##########################################################################################
 # Checks if current folder is a VCS and if so, finds the location of the root repository.
 # Globals:
 #   None
 # Arguments:
 #   None
 # Returns
 #   VCS_REPO_ROOT as String
 ##########################################################################################
 function system::vcs_repo_root() {

   local VCS_REPO_ROOT;
   VCS_REPO_ROOT="";

   # Check if repository is a git repo
   if git rev-parse --is-inside-work-tree 2> /dev/null; then
     # This is a valid git repository.
     VCS_REPO_ROOT="$(git rev-parse --show-toplevel)";

   elif hg --cwd ./ root 2> /dev/null; then
     # This is a valid mercurial repository.
     VCS_REPO_ROOT="$(hg root)";

   elif svn ls ./ > /dev/null; then
     # This is a valid svn repository.
     VCS_REPO_ROOT="$(svn info --show-item wc-root)";
   fi
 
   if [[ -z VCS_REPO_ROOT ]]; then
     echo $VCS_REPO_ROOT;
   else
     system:err "Current directory is not within a vcs repository. Terminating program.";
     exit 1;
   fi 
 }
 #+END_SRC

*** Colors & Text attributes                         :function:constant:bash:

 Because all the colors and fancy effects! Shamelessly stolen from https://github.com/ralish/bash-script-template/blob/stable/template.sh 

 #+CAPTION: Colors available for tput
 |-----+---------+---------------+-------|
 | Num | Colour  | #define       | R G B |
 |-----+---------+---------------+-------|
 |   0 | black   | COLOR_BLACK   | 0,0,0 |
 |   1 | red     | COLOR_RED     | 1,0,0 |
 |   2 | green   | COLOR_GREEN   | 0,1,0 |
 |   3 | yellow  | COLOR_YELLOW  | 1,1,0 |
 |   4 | blue    | COLOR_BLUE    | 0,0,1 |
 |   5 | magenta | COLOR_MAGENTA | 1,0,1 |
 |   6 | cyan    | COLOR_CYAN    | 0,1,1 |
 |   7 | white   | COLOR_WHITE   | 1,1,1 |
 |-----+---------+---------------+-------|


 #+NAME: system::color_initialization
 #+BEGIN_SRC sh :noweb yes
 ################################################
 # Initialise colour variables and text options
 # Global: 
 #   None
 # Arguments:
 #   None:
 # Returns:
 #   None
 ################################################
 function colour_init() {
     if [[ -z ${no_colour-} ]]; then

         readonly reset_color="$(tput sgr0 2> /dev/null || true)"
         <<colors_text_attributes>>

         <<colors_foreground>>

         <<colors_background>>
     else
         readonly reset_color=''
         <<colors_null_values>>
     fi
 }
 #+END_SRC

**** colors_text_attributes                                   :constant:bash:

Text attributes can be changed by writing "ta_" followed by the particular text attribute you want. The options are:

#+CAPTION: Different text attribute options
 |-----------+---------------------------------|
 | Command   | Description                     |
 |-----------+---------------------------------|
 | tput bold | # Select bold mode              |
 | tput dim  | # Select dim (half-bright) mode |
 | tput smul | # Enable underline mode         |
 | tput rmul | # Disable underline mode        |
 | tput rev  | # Turn on reverse video mode    |
 | tput smso | # Enter standout (bold) mode    |
 | tput rmso | # Exit standout mode            |
 |-----------+---------------------------------|

 #+NAME: colors_text_attributes
 #+BEGIN_SRC sh
 # Text attributes
 readonly ta_bold="$(tput bold 2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly ta_uscore="$(tput smul 2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly ta_blink="$(tput blink 2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly ta_reverse="$(tput rev 2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly ta_conceal="$(tput invis 2> /dev/null || true)"
 printf '%b' "$ta_none"
 #+END_SRC

**** colors_foreground                                        :constant:bash:

 #+CAPTION: Colors available for tput
 |-----+---------+---------------+-------|
 | Num | Colour  | #define       | R G B |
 |-----+---------+---------------+-------|
 |   0 | black   | COLOR_BLACK   | 0,0,0 |
 |   1 | red     | COLOR_RED     | 1,0,0 |
 |   2 | green   | COLOR_GREEN   | 0,1,0 |
 |   3 | yellow  | COLOR_YELLOW  | 1,1,0 |
 |   4 | blue    | COLOR_BLUE    | 0,0,1 |
 |   5 | magenta | COLOR_MAGENTA | 1,0,1 |
 |   6 | cyan    | COLOR_CYAN    | 0,1,1 |
 |   7 | white   | COLOR_WHITE   | 1,1,1 |
 |-----+---------+---------------+-------|

 #+NAME: colors_foreground
 #+BEGIN_SRC sh
 # Foreground codes
 readonly fg_black="$(tput setaf 0     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_blue="$(tput setaf 4      2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_cyan="$(tput setaf 6      2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_green="$(tput setaf 2     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_magenta="$(tput setaf 5   2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_red="$(tput setaf 1       2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_white="$(tput setaf 7     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly fg_yellow="$(tput setaf 3    2> /dev/null || true)"
 printf '%b' "$ta_none"
 #+END_SRC

**** colors_background                                        :constant:bash:

 #+CAPTION: Colors available for tput
 |-----+---------+---------------+-------|
 | Num | Colour  | #define       | R G B |
 |-----+---------+---------------+-------|
 |   0 | black   | COLOR_BLACK   | 0,0,0 |
 |   1 | red     | COLOR_RED     | 1,0,0 |
 |   2 | green   | COLOR_GREEN   | 0,1,0 |
 |   3 | yellow  | COLOR_YELLOW  | 1,1,0 |
 |   4 | blue    | COLOR_BLUE    | 0,0,1 |
 |   5 | magenta | COLOR_MAGENTA | 1,0,1 |
 |   6 | cyan    | COLOR_CYAN    | 0,1,1 |
 |   7 | white   | COLOR_WHITE   | 1,1,1 |
 |-----+---------+---------------+-------|

 #+NAME: colors_background
 #+BEGIN_SRC sh
 # Background codes
 readonly bg_black="$(tput setab 0     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_blue="$(tput setab 4      2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_cyan="$(tput setab 6      2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_green="$(tput setab 2     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_magenta="$(tput setab 5   2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_red="$(tput setab 1       2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_white="$(tput setab 7     2> /dev/null || true)"
 printf '%b' "$ta_none"
 readonly bg_yellow="$(tput setab 3    2> /dev/null || true)"
 printf '%b' "$ta_none"
 #+END_SRC

**** colors_null_values                                       :constant:bash:
 If we don't use colors in our code but still put references to it in our code, it might cause annoying issues.
 We'll be setting them to '' so that nothing happens and our code is safe.
 #+NAME: colors_null_values
 #+BEGIN_SRC sh
 # Text attributes
 readonly ta_bold=''
 readonly ta_uscore=''
 readonly ta_blink=''
 readonly ta_reverse=''
 readonly ta_conceal=''

 # Foreground codes
 readonly fg_black=''
 readonly fg_blue=''
 readonly fg_cyan=''
 readonly fg_green=''
 readonly fg_magenta=''
 readonly fg_red=''
 readonly fg_white=''
 readonly fg_yellow=''

 # Background codes
 readonly bg_black=''
 readonly bg_blue=''
 readonly bg_cyan=''
 readonly bg_green=''
 readonly bg_magenta=''
 readonly bg_red=''
 readonly bg_white=''
 readonly bg_yellow=''
 #+END_SRC

*** POSIX compliant echo                                      :function:bash:

 While echo is a rather common tool, it's actually terribly designed. It's only portable if you don't any use flags and it's output isn't consistent. 
 We'll be using printf instead, which is POSIX-compliant and much better designed. As a special function, it will be listed as both system::echo and echo, for ease of use.
#+NAME: system::echo
 #+BEGIN_SRC sh
 ######################################################
 # Makes echo POSIX-compliant while retaining options
 # Globals:
 #   None
 # Arguments:
 #   None
 # Returns:
 #   None
 ######################################################
 function echo () (
 fmt=%s end=\\n IFS=" "

 while [ $# -gt 1 ] ; do
 case "$1" in
 [!-]*|-*[!ne]*) break ;;
 *ne*|*en*) fmt=%b end= ;;
 *n*) end= ;;
 *e*) fmt=%b ;;
 esac
 shift
 done

 printf "$fmt$end" "$*"
 )

 function ok() {
    echo -e "\n $fg_green [ok] $fg_black " $1
 }

 function bot() {
     echo -e "\n $fg_green \[._.]/$fg_black - "$1
 }

 function running() {
     echo -en "$fg_yellow \u21d2 $fg_black"$1": "
 }

 function action() {
     echo -e "\n $fg_yellow [action]: $fg_black \n \u21d2 $1..."
 }

 function warn() {
     echo -e "$COL_YELLOW[warning]$COL_RESET "$1
 }

 function error() {
     echo -e "$COL_RED[error]$COL_RESET "$1
 }
  #+End_SRC

* Applications to install

In this section, we'll be listing the application name and general info, it's package name for our package manager to install it, and any configuration files related to said software.

This allows us to create a list of all applications that we'll need in a single file while keeping them all nice and organized in seperate categories. Keep in mind that programming languages are not included in this section (they have special requirements for a proper development environment) but applications that are installed using a language's package manager belong here.

+ *Conventions*
  + Any headline that's an application must have the application tag. 
    + If the application name is not immediately indicative of its purpose, a brief description of its type can be included after a hypen.
  + Any installation code block in this section should have the tag :install:, headline Installation and name 'install'
  + All configuration files must have a parent headline called 'Configuration' with tag :configuration:
    + If the configuration file is worthy of it's own org file, a link shall be provided for the same.
  + If an application is installed with a programming language's package manager, use an appropriate tag and src block name.
    - 
      | Language | tag     | src block name  | 
      | Python 2 | python2 | python2_install |
      | Python 3 | python3 | python3_install |

#+BEGIN_EXAMPLE 
  ** General application category
  *** Application name - type of application (if required)        :application:
  **** Installation
  #+NAME: install
  #+BEGIN_SRC sh :padline no :tangle no :noweb yes
  
  #+END_SRC
#+END_EXAMPLE

#+NAME: applications_to_install
#+BEGIN_SRC sh :noweb yes
  zypper in -y <<install>>
#+END_SRC

** Terminal Emulators
Plenty of shells for a hermit crab to choose. I'm going with fish for my interactive shell and bash for my scripts. Will try zsh for specific types of repositories.
*** fish                                                        :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
fish
#+END_SRC

*** bash                                                        :application:
**** Installation                                                   :install:
While you shouldn't really have to install bash on a system (since it should just be there), I'm adding this for the sake of completionists everywhere.
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
bash
#+END_SRC

**** Configuration                                            :configuration:
***** Navigation
****** Easier navigation: .., ..., ...., and .....
  #+BEGIN_SRC sh :tangle bashrc.txt :padline no
  alias ..="cd .."
  alias ...="cd ../.."
  alias ....="cd ../../.."
  alias .....="cd ../../../.."
  #+END_SRC
****** Shortcuts to commonly used folders
  #+BEGIN_SRC sh :tangle bashrc.txt :padline no
  alias downloads="cd ~/Downloads"
  alias desktop="cd ~/Desktop"
  alias projects="cd ~/Projects"
  #+END_SRC
****** Shortcuts to commonly used commands
  #+BEGIN_SRC sh :tangle bashrc.txt :padline no
  alias g="git"
  alias h="history"
  #+END_SRC

***** grep
****** Always enable colored `grep` output
  # Note: `GREP_OPTIONS="--color=auto"` is deprecated, hence the alias usage.
  #+BEGIN_SRC sh :tangle bashrc.txt
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
  #+END_SRC

***** Enable aliases to be sudo’ed
 #+BEGIN_SRC sh :tangle bashrc.txt
 alias sudo='sudo '
 #+END_SRC

***** Get week number
 #+BEGIN_SRC sh :tangle bashrc.txt
 alias week='date +%V'
 #+END_SRC

***** Stopwatch
  #+BEGIN_SRC sh :tangle bashrc.txt
 alias timer='echo "Timer started. Stop with Ctrl-D." && date && time cat && date'
 #+END_SRC

 #+RESULTS:
***** COMMENT Updates and Cleanups
****** COMMENT Get OS X Software Updates, and update installed Ruby gems, Homebrew, npm, and their installed packages
  #+BEGIN_SRC sh :tangle bashrc.txt
  alias update='sudo softwareupdate -i -a; brew update; brew upgrade --all; brew cleanup; npm install npm -g; npm update -g; sudo gem update --system; sudo gem update'
  #+END_SRC
****** COMMENT Flush Directory Service cache
  #+BEGIN_SRC sh :tangle bashrc.txt
  alias flush="dscacheutil -flushcache && killall -HUP mDNSResponder"
  #+END_SRC
****** COMMENT Clean up LaunchServices to remove duplicates in the “Open With” menu
   #+BEGIN_SRC sh :tangle/basrcs.txt
   alias lscleanup="/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user && killall Finder"
   #+END_SRC
****** COMMENT Recursively delete `.DS_Store` files
  #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
  alias DSStorecleanup="find . -type f -name '*.DS_Store' -ls -delete"
  #+END_SRC
****** COMMENT Empty trash
  # Empty the Trash on all mounted volumes and the main HDD.
  # Also, clear Apple’s System Logs to improve shell startup speed.
  # Finally, clear download history from quarantine. https://mths.be/bum
  #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
  alias emptytrash="sudo rm -rfv /Volumes/*/.Trashes; sudo rm -rfv ~/.Trash; sudo rm -rfv /private/var/log/asl/*.asl; sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* 'delete from LSQuarantineEvent'"
  #+END_SRC

***** Encryption
****** OS X has no `md5sum`, so use `md5` as a fallback
  #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
  command -v md5sum > /dev/null || alias md5sum="md5"
  #+END_SRC
****** OS X has no `sha1sum`, so use `shasum` as a fallback
  #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
  command -v sha1sum > /dev/null || alias sha1sum="shasum"
  #+END_SRC
****** Canonical hex dump; some systems have this symlinked
  #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
  command -v hd > /dev/null || alias hd="hexdump -C"
  #+END_SRC

***** Intuitive map function
 # For example, to list all directories that contain a certain file:
 # find . -name .gitattributes | map dirname
 #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
 alias map="xargs -n1"
 #+END_SRC

***** One of @janmoesen’s ProTip™s
 #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
 for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
	 alias "$method"="lwp-request -m '$method'"
 done
 #+END_SRC

***** Stuff I never really use but cannot delete either because of http://xkcd.com/530/
 #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt
 alias stfu="osascript -e 'set volume output muted true'"
 alias pumpitup="osascript -e 'set volume 7'"
 #+END_SRC

*** zsh                                                         :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
zsh
#+END_SRC

*** libntify                                               :application:

 Use notify-send to create notifications from terminal. Use C-c C-c to execute this code block for an example

 #+BEGIN_SRC sh
 notify-send 'Hello world' 'Hello world'
 #+END_SRC
**** Installation                                                   :install:
 #+NAME: install 
 #+BEGIN_SRC sh
 libnotify-tools
 #+END_SRC



 #+RESULTS:

** Browsers
*** Chromium                                                    :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
chromium
#+END_SRC

*** Firefox                                                     :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
firefox
#+END_SRC

*** Tor                                                         :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
tor
#+END_SRC

** Text editors
*** Emacs                                                       :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
emacs
#+END_SRC

** Version Control
*** Git                                                         :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
git
#+END_SRC

**** Configuration                                            :configuration:
***** TODO COMMENT git config
   What would you do without our favourite git config?
   Or rather, what can you do to avoid forgetting that the damn thing doesn't exist anytime you use a new machine.
   This should make life much better (and less frustrating.)

   As for why we've doing this via commands instead of just dumping all our settings in a .gitconfig file?
   Well, this script can be run on any system and I'd rather git know where to install stuff than have to know it myself.
   Sure it's ugly but it works. And more importantly, I have a reference for when I have to do this for the thousandth time on someone else's computer and I don't necessarily want to overwrite their script and a command just works.

   Also, it allows me to refer to this document anytime I want and copy paste code without thinking.
****** User name and email
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global user.name 'Vi Kumar'
   git config --global user.email 'grokkingStuff@gmail.com'
   #+END_SRC

****** Default Editor
   Changing the editor to emacs because I prefer using an actual editor instead of the vim prompt.
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global core.editor $EDITOR
   #+END_SRC

****** git compression
   Changing the git compression to be best. I tend to use VCS where I shouldn't.
   + 0 - no compression/highest speed
   + 9 - best compression/slowest speed
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global core.compression 9
   #+END_SRC

****** autocorrect common mistakes
   My fingers are never really under my control.
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global help.autocorrect 1
   #+END_SRC

****** Colored Output
   Allowing all git commands to use colored output.
   Because a little bit of color ain't never gonna hurt nobody.
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global color.ui auto
   #+END_SRC

****** Git Aliases
   Because aliases are pretty handy when you find yourself repeating the same commands over and over again.
   Honestly, everything in this list is more important then everything above.
******* Tweak defaults
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global alias.diff diff --word-diff
   git config --global alias.branch branch -ra
   git config --global alias.grep grep -Ii
   git config --global alias.bra branch -ra
   git config --global alias.ai add --interactive
   #+END_SRC

******* Common git aliases
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   # Common git aliases
   git config --global alias.st status
   git config --global alias.ci commit
   git config --global alias.co checkout
   git config --global alias.br branch
   #+END_SRC

******* Pretty History
   #+BEGIN_SRC sh :tangle git/git_config.sh
   # Gives you a pretty history
   git config --global alias.lg log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
   git config --global alias.lga log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative --branches
   #+END_SRC

   Should probably work on this someday. Would be nice to see multiple options for a git history instead of memorising each one.
   #+BEGIN_SRC sh
   hist = !echo ''/
       read -p "What kind of history do you want?" ans
       case $ans in
           [1a]* ) make install; break;;
           [2b]* ) exit;;
           [3c]* ) exit;;
           [4d]* ) exit;;
           * ) echo "Select a valid option.";;
   #+END_SRC

******* Show configured aliases
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global alias.aliases !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\ \t => \\2/' | sort
   #+END_SRC

******* Rename branch to done-branch
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global alias.done "!f() { git branch | grep "$1" | cut -c 3- | grep -v done | xargs -I{} git branch -m {} done-{}; }; f"
   #+END_SRC

******* Reset Aliases
   Please try to avoid them. Please! I hate having to deal with this.......
   #+BEGIN_SRC sh :tangle git/git_config.sh :padline no
   git config --global alias.r reset
   git config --global alias.r1 reset HEAD^
   git config --global alias.r2 reset HEAD^^
   git config --global alias.rh reset --hard
   git config --global alias.rh1 reset HEAD^ --hard
   git config --global alias.rh2 reset HEAD^^ --hard
   #+END_SRC

***** TODO COMMENT git ignore
   Because no one should never have to deal with adding specific gitignores for every single project.
   Especially when it comes to temporary files created by IDEs and OS-specific files.
   Also it's super annoying to manually remove files each and every time you commit.

   That would be a humans rights violation. Even genocidal dictators don't go that far in order to torture you.
   Right?

   #+BEGIN_SRC sh :tangle git/git_ignore.sh
   # move your globalgitignore from the appropiate folder to the home directory.
   mv ./gitignore_global.txt $HOME/.gitignore_global

   # actually make the file the global ignore
   git config --global core.excludesfile $HOME/.gitignore_global
   #+END_SRC

****** .gitignore_global
   As you can see, the .gitignore_global is an actual file. The file will be called gitignore_global.txt
   We'll be writing our settings into the gitignore_global.txt file for our git_configuration script to use.
******* Compiled Source
   #+BEGIN_SRC sh :tangle git/gitignore_global.txt :padline no
   *.com
   *.class
   *.dll
   *.exe
   *.o
   *.so
   #+END_SRC

******* Packages
   It's better to unpack these files and commit the raw source.
   git has its own built in compression methods.
   #+BEGIN_SRC sh :tangle git/gitignore_global.txt :padline no
   *.7z
   *.dmg
   *.gz
   *.iso
   *.jar
   *.rar
   *.tar
   *.zip
   #+END_SRC

******* Logs and databases
   It's for the best that you don't reveal secret logs and databases. Data is private - keep it that way.
   #+BEGIN_SRC sh :tangle git/gitignore_global.txt :padline no
   *.log
   *.sql
   *.sqlite
   #+END_SRC

******* OS generated files
   #+BEGIN_SRC sh :tangle git/gitignore_global.txt :padline no
   .DS_Store
   .DS_Store?
   ._*
   .Spotlight-V100
   .Trashes
   ehthumbs.db
   Thumbs.db
    #+END_SRC

******* Codekits
   #+BEGIN_SRC sh :tangle git/gitignore_global.txt :padline no
   .sass-cache/
   .codekit-config.json
   config.codekit
   #+END_SRC

***** TODO COMMENT git attribute
   Kinda need to add to this section. I feel that a list of git attributes for each language would be helpful.
***** TODO COMMENT git-lfs
   Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git,
   while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.

****** Installation
   #+BEGIN_SRC sh :tangle git/git_config.sh
   $PACKAGEMANAGER install git-lfs
   git lfs install
   #+END_SRC

****** Use in a repo
   If you want to use git-lfs in a repository, simply apply the lfs install command inside the repo.
   #+BEGIN_SRC sh :tangle no
   # inside your repo
   git lfs install
   #+END_SRC

   This will update the pre-push hook for that git repo.

****** Speeding up clones containing a lot of lfs files
   If you're cloning a repository with a large number of LFS files, the explicit git lfs clone command offers far better performance.
   It does this by waiting untill all non-lfs files are downloaded and then using a parallel download of all lfs files as a batch.

   Honestly, I think git clone should just be git lfs clone by default. I'm not making that an alias but you could in the future.

***** TODO COMMENT bash aliases for git
      Git aliases are always pretty useful so we're gonna add them too
   #+BEGIN_SRC sh :tangle terminalEmulator/bash/bash_aliases.txt :padline no
   alias gs='git status '
   alias ga='git add '
   alias gb='git branch '
   alias gam='git commit --amend '
   alias gc='git commit'
   alias gd='git diff'
   alias gt='git checkout '
   alias gk='gitk --all&'
   alias gx='gitx --all'
   alias pull='git pull'
   alias pullo='git pull origin'
   alias push='git push'
   alias pusho='git push origin'
   alias pushf='git push -f origin'
   alias pushu='git push -u origin'
   alias merge='git merge'
   alias got='git '
   alias get='git '
   alias clone='git clone'
   alias add='git add'
   #+END_SRC

** Media
*** VLC - Video Player                                          :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
vlc
#+END_SRC

*** Vocal - Podcast Client                                      :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
vocal
#+END_SRC

*** youtube-dl - Downloader for youtube videos                  :application:
**** Installation                                           :python2:install:
#+NAME: python2_install
#+BEGIN_SRC txt :padline no :tangle no :noweb yes
youtube-dl
#+END_SRC

** Activity Monitor
*** htop                                                        :application:
**** Installation                                                   :install:
#+NAME: install
#+BEGIN_SRC sh :padline no :tangle no :noweb yes
htop
#+END_SRC

**** Configuration                                            :configuration:
 All configuration options are located in the .htoprc file.
 Stolen from god knows where - seems like everyone uses it.

 #+BEGIN_SRC sh :tangle htoprc.txt
 # Beware! This file is rewritten every time htop exits.
 # The parser is also very primitive, and not human-friendly.
 # (I know, it's in the todo list).
 fields=0 48 17 18 38 39 40 2 46 47 49 1
 sort_key=46
 sort_direction=1
 hide_threads=0
 hide_kernel_threads=1
 hide_userland_threads=0
 shadow_other_users=0
 highlight_base_name=0
 highlight_megabytes=1
 highlight_threads=0
 tree_view=0
 header_margin=1
 detailed_cpu_time=1
 color_scheme=0
 delay=15
 left_meters=Hostname Tasks LoadAverage Uptime Memory Memory Swap CPU CPU
 left_meter_modes=2 2 2 2 1 2 1 1 2
 right_meters=AllCPUs
 right_meter_modes=1
 #+END_SRC

* Organization
** Dropbox

#+NAME: install
#+BEGIN_SRC sh 
dropbox
#+END_SRC

** Folder Organization
#+NAME: organization
#+BEGIN_SRC sh :noweb yes 
dropbox start
if [ -d "~/Dropbox" ]; then
    dropbox start
    dropbox status

    <<organization_folder>>

    <<organization_file>>
fi
#+END_SRC

*** Projects
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Projects
ln ~/Dropbox/Projects ~/Projects
#+END_SRC

*** Agenda
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Agenda
ln ~/Dropbox/Agenda ~/Agenda
#+END_SRC

*** Documents
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Documents
ln ~/Dropbox/Documents ~/Documents
#+END_SRC

*** Configuration
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Configuration
ln ~/Dropbox/Configuration ~/Configuration
#+END_SRC

*** Archive
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Archive
ln ~/Dropbox/Archive ~/Archive
#+END_SRC

*** Website
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Website
ln ~/Dropbox/Website ~/Website
#+END_SRC

*** Learning
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Learning
ln ~/Dropbox/Learning ~/Learning
#+END_SRC

*** Medical
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Medical
ln ~/Dropbox/Medical ~/Medical
#+END_SRC

*** Asset Management
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/AssetManagement
ln ~/Dropbox/AssetManagement ~/AssetManagement
#+END_SRC

*** Business
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Business
ln ~/Dropbox/Business ~/Business
#+END_SRC

*** Photos
#+NAME: organization_folder
#+BEGIN_SRC sh
touch ~/Dropbox/Photos
ln ~/Dropbox/Photos ~/Photos
#+END_SRC

** File Management

*** organizer.org

Items that should be in organizer.org

- Tasks
- Important dates
  + Anniversary
  + Expiry Date of Credit Cards
    Inform one week in advance
  + Bills to be paid
  + Membership days
  + Religious Holiday
  + Government Holiday
  + Conference Periods
  + College Events



#+NAME: organization_file
#+BEGIN_SRC sh
touch ~/Dropbox/organizer.org
ln ~/Dropbox/organizer.org ~/organizer.org
# Place in Agenda for org-agenda
mkdir -p ~/Dropbox/Agenda
ln ~/Dropbox/organizer.org ~/Dropbox/Agenda/organizer.org
#+END_SRC

*** refile.org

Main org file for org-capture and todo tasks.
#+NAME: organization_file
#+BEGIN_SRC sh
touch ~/Dropbox/refile.org
ln ~/Dropbox/refile.org ~/refile.org
# Place in Agenda for org-agenda
mkdir -p ~/Dropbox/Agenda
ln ~/Dropbox/refile.org ~/Dropbox/Agenda/refile.org
#+END_SRC

*** meeting.org

For meetings that would have been in organizer.org
#+NAME: organization_file
#+BEGIN_SRC sh
touch ~/Dropbox/meeting.org
ln ~/Dropbox/meeting.org ~/meeting.org
# Place in Agenda for org-agenda
mkdir -p ~/Dropbox/Agenda
ln ~/Dropbox/meeting.org ~/Dropbox/Agenda/meeting.org
#+END_SRC

* Python Environment Configuration
#+NAME: python
#+BEGIN_SRC sh :noweb yes
#########
# Pyenv #
#########

<<python_pyenv>>

#+END_SRC
** Pyenv
pyenv is used to isolate Python versions. For example, you may want to test your code against Python 2.6, 2.7, 3.3, 3.4 and 3.5, so you'll need a way to switch between them. Once activated, it prefixes the PATH environment variable with ~/.pyenv/shims, where there are special files matching the Python commands (python, pip). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the PYENV_VERSION environment variable, or the .python-version file, or the ~/.pyenv/version file. pyenv also makes the process of downloading and installing multiple Python versions easier, using the command pyenv install.

*** Installation of pyenv and extensions                            :install:

We won't be installing pyenv through zypper since zypper doesn't have it unless you add someone's personal repo (which I am unwilling to do).
Instead, we'll be installing it through cloning a git repo. Since pyenv is just a bunch of shell scripts, we'll be alright.

#+NAME: python_pyenv
#+BEGIN_SRC sh 
# Taken from https://www.reddit.com/r/openSUSE/comments/70ozge/using_multiple_python_versions_on_leap/dos6798

git clone https://github.com/pyenv/pyenv.git ~/.pyenv
echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.bashrc

# Install the missing headers needed by Python modules
sudo zypper install readline-devel sqlite3-devel libbz2-devel zlib-devel libopenssl-devel

# Install virtualvenv
sudo zypper install python3-virtualenv
#+END_SRC

*** Installing different versions of python
 Installing new Python versions is very straightforward. All Python versions are installed in the versions directory under the pyenv root.

 #+NAME: python_pyenv
 #+CAPTION: Install CPython 3.6.0 and CPython 2.7.13.
 #+BEGIN_SRC sh
 pyenv install 3.6.0
 pyenv install 2.7.13
 #+END_SRC

*** virtualvenv setup
 With virtualenv all your virtualenvs are kept on a same directory and your projects' code on another. My setup is:
 #+NAME: python_pyenv
 #+BEGIN_SRC sh :padline no
 # All virtualenvs will be on...
 # export WORKON_HOME=~/.ve
 mkdir -p ~/.ve 

 # All projects will be on...
 # export PROJECT_HOME=~/Projects
 mkdir -p ~/Projects 

 # The -p flag is in case these folders have been created earlier - without it, mkdir returns an error.
 #+END_SRC

 It's necessary to configure the shell to initialize pyenv when you start a terminal session. Put the lines bellow on your ~/.bashrc file:
 #+NAME: bashrc
 #+BEGIN_SRC sh :padline no
 export PATH="~/.pyenv/bin/:$PATH"

 export WORKON_HOME=~/.ve
 export PROJECT_HOME=~/Projects
 if which pyenv > /dev/null; then eval "$(pyenv init -)"; fi
 #+END_SRC

*** Resist the temptation to contaminate your global Python install

 I frequently use programs written in Python. I like them to be available in all sessions without activate any virtualenv.

 However I don't like to mess with the global Python installation to avoid library conflict issues.

 Another thing that I don't like is installing Jupyter/iPython on each of my projects' virtualenvs.

 I like to have only one install of Jupyter Notebook , one of iPython Console for Python3, one of iPython Console for Python2, and other tools like youtube-dl, rename, gnucash-to-beancount, rows, s3cmd, fabric, mercurial, etc.

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 pyenv virtualenv 3.6.0 jupyter3
 pyenv virtualenv 3.6.0 tools3
 pyenv virtualenv 2.7.13 ipython2
 pyenv virtualenv 2.7.13 tools2
 #+END_SRC

 Jupyter supports many kernels. This allows a single Jupyter install to create notebooks for Python2, Python3, R, Bash and many other languages. At this time I only want to support Python2 and Python3.

**** Installing jupyter under jupyter3

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 pyenv activate jupyter3
 pip install jupyter
 python -m ipykernel install --user
 pyenv deactivate
 #+END_SRC

**** Installing ipython under ipython2

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 pyenv activate ipython2
 pip install ipykernel
 python -m ipykernel install --user
 pyenv deactivate
 #+END_SRC

 Note that when I install Jupyter on Python3 it will by default install iPython and the Kernel too. For Python2 I only need to install iPython and the Kernel. I'll explain this better bellow.

**** Tools which run on Python 3

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 pyenv activate tools3
 pip install youtube-dl gnucash-to-beancount rows 
 pyenv deactivate
 #+END_SRC

**** Tools that only run on Python 2

#+NAME: python_pyenv
 #+BEGIN_SRC sh 
 pyenv activate tools2
 pip install rename s3cmd fabric mercurial
 pyenv deactivate
 #+END_SRC

**** Final Step
 Finally, it's time to make all Python versions and special virtualenvs work with each other.

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 pyenv global 3.6.0 2.7.13 jupyter3 ipython2 tools3 tools2
 #+END_SRC

 The above command establishes the PATH priority so scripts can be accessed in the right order without activating any virtualenv.

*** How to use Jupyter and iPython with my projects?

 This was the main motivation to write this guide.

 Both Notebook and Console were part of the iPython project, which, as the name suggests, were only about Python. But the Notebook evolution enabled it to become language agnostic, so developers decided to split the project in 2: Jupyter and iPython

 Now Jupyter contains Notebook, while iPython contains Console and the Python Kernel which Jupyter uses to execute Python code.

 I used to use an old iPython version and during a clumsy upgrade Jupyter stopped detecting the active virtualenv, so I couldn't import its installed libraries.

 Actually, Jupyter does not detect the active virtualenv: it's the iPython instance which Jupyter initializes. The problem then is that iPython's virtualenv detection code only runs in the interactive shell mode, but not in the kernel mode. Besides that the detection code only works properly if the active virtualenv's Python version and the Python version running iPython are the same.

 The solution is to customize iPython's startup process. For that we need to create an iPython profile and install a magic script I wrote to do the trick:

#+NAME: python_pyenv
 #+BEGIN_SRC sh
 ipython profile create
 curl -L http://hbn.link/hb-ipython-startup-script > ~/.ipython/profile_default/startup/00-venv-sitepackages.py
 #+END_SRC
 With this, no matter the mode iPython starts, the virtualenv's site-packages will be available in the PYTHONPATH.

 Back to our proj3, after activating its virtualenv running workon proj3, you can simply execute ipython to run the interactive mode, or jupyter notebook to get all the fun.

** Pylint

